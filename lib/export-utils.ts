// types.ts
export interface ExportOptions {
  includeHeader: boolean
  includeFooter: boolean
  includeTimestamp: boolean
  customStyles?: string
  pageMargins?: string
}

export interface ExportData {
  content: string
  title: string
  options: ExportOptions
}

export type ExportFormat = 'pdf' | 'docx' | 'txt' | 'html'

// utils/fileUtils.ts
export const downloadFile = (blob: Blob, filename: string): void => {
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  
  link.href = url
  link.download = filename
  link.style.display = 'none'
  
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  
  // Clean up the URL object
  setTimeout(() => URL.revokeObjectURL(url), 100)
}

export const escapeHtml = (text: string): string => {
  const htmlEscapes: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  }
  
  return text.replace(/[&<>"']/g, (match) => htmlEscapes[match] || match)
}

// services/contentProcessor.ts
export class ContentProcessor {
  private static addHeader(content: string, title: string): string {
    const separator = '='.repeat(Math.max(title.length, 50))
    return `${title}\n${separator}\n\n${content}`
  }

  private static addFooter(content: string, includeTimestamp: boolean): string {
    const separator = '_'.repeat(50)
    const footerBase = `\n\n${separator}\nGenerated by LegalDoc AI`
    
    if (includeTimestamp) {
      const timestamp = new Date().toLocaleString()
      return `${content}${footerBase}\nGenerated on: ${timestamp}`
    }
    
    return `${content}${footerBase}`
  }

  static processContent(data: ExportData): string {
    let processedContent = data.content

    if (data.options.includeHeader) {
      processedContent = this.addHeader(processedContent, data.title)
    }

    if (data.options.includeFooter) {
      processedContent = this.addFooter(processedContent, data.options.includeTimestamp)
    }

    return processedContent
  }

  static generateHtmlContent(data: ExportData): string {
    const processedContent = this.processContent(data)
    const { title, options } = data
    
    const defaultStyles = `
      body { 
        font-family: Arial, sans-serif; 
        line-height: 1.6; 
        margin: ${options.pageMargins || '40px'}; 
        color: #333;
      }
      h1 { 
        border-bottom: 2px solid #333; 
        padding-bottom: 10px;
        margin-bottom: 30px;
      }
      .content { 
        white-space: pre-wrap; 
        word-wrap: break-word; 
        margin-bottom: 40px;
      }
      .footer { 
        margin-top: 40px; 
        padding-top: 20px;
        font-size: 12px; 
        color: #666; 
        border-top: 1px solid #eee;
      }
      @media print {
        body { margin: 20px; }
        .footer { page-break-inside: avoid; }
      }
    `

    const styles = options.customStyles ? `${defaultStyles}\n${options.customStyles}` : defaultStyles

    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  <style>${styles}</style>
</head>
<body>
  <h1>${escapeHtml(title)}</h1>
  <div class="content">${escapeHtml(processedContent)}</div>
  ${options.includeFooter ? `
  <div class="footer">
    Generated by LegalDoc AI${options.includeTimestamp ? ` on ${new Date().toLocaleString()}` : ''}
  </div>` : ''}
</body>
</html>`
  }
}

// services/exporters/baseExporter.ts
export abstract class BaseExporter {
  protected data: ExportData

  constructor(data: ExportData) {
    this.data = data
  }

  abstract export(): Promise<void>
  
  protected getFilename(extension: string): string {
    // Sanitize filename
    const sanitizedTitle = this.data.title.replace(/[^\w\s-]/gi, '').trim()
    return `${sanitizedTitle}.${extension}`
  }
}

// services/exporters/pdfExporter.ts
import html2pdf from 'html2pdf.js'

export class PdfExporter extends BaseExporter {
  async export(): Promise<void> {
    try {
      const htmlContent = ContentProcessor.generateHtmlContent(this.data)
      const element = document.createElement('div')
      element.innerHTML = htmlContent

      // Use the options format that html2pdf expects
      const options = {
        margin: 10,
        filename: this.getFilename('pdf'),
        image: { 
          type: 'jpeg' as const, 
          quality: 0.98 
        },
        html2canvas: { 
          scale: 2, 
          useCORS: true 
        },
        jsPDF: { 
          unit: 'mm', 
          format: 'a4', 
          orientation: 'portrait' as const
        }
      }

      await html2pdf().set(options).from(element).save()
    } catch (error) {
      throw new Error(`PDF export failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }
}

// services/exporters/docxExporter.ts
export class DocxExporter extends BaseExporter {
  async export(): Promise<void> {
    try {
      const htmlContent = ContentProcessor.generateHtmlContent(this.data)
      
      const response = await fetch('/api/convert-to-docx', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          htmlContent, 
          title: this.data.title,
          options: this.data.options 
        }),
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown server error' }))
        throw new Error(errorData.error || `Server error: ${response.status}`)
      }

      const docxBlob = await response.blob()
      downloadFile(docxBlob, this.getFilename('docx'))
    } catch (error) {
      throw new Error(`DOCX export failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }
}

// services/exporters/txtExporter.ts
export class TxtExporter extends BaseExporter {
  async export(): Promise<void> {
    try {
      const processedContent = ContentProcessor.processContent(this.data)
      const blob = new Blob([processedContent], { type: 'text/plain;charset=utf-8' })
      downloadFile(blob, this.getFilename('txt'))
    } catch (error) {
      throw new Error(`TXT export failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }
}

// services/exporters/htmlExporter.ts
export class HtmlExporter extends BaseExporter {
  async export(): Promise<void> {
    try {
      const htmlContent = ContentProcessor.generateHtmlContent(this.data)
      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' })
      downloadFile(blob, this.getFilename('html'))
    } catch (error) {
      throw new Error(`HTML export failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }
}

// services/exportFactory.ts
type ExporterConstructor = new (data: ExportData) => BaseExporter

export class ExportFactory {
  private static exporters: Record<ExportFormat, ExporterConstructor> = {
    pdf: PdfExporter as ExporterConstructor,
    docx: DocxExporter as ExporterConstructor,
    txt: TxtExporter as ExporterConstructor,
    html: HtmlExporter as ExporterConstructor
  }

  static createExporter(format: ExportFormat, data: ExportData): BaseExporter {
    const ExporterClass = this.exporters[format]
    
    if (!ExporterClass) {
      throw new Error(`Unsupported export format: ${format}`)
    }

    return new ExporterClass(data)
  }

  static getSupportedFormats(): ExportFormat[] {
    return Object.keys(this.exporters) as ExportFormat[]
  }
}

// Main export service
export class DocumentExportService {
  static async exportDocument(
    format: ExportFormat,
    content: string,
    title: string,
    options: ExportOptions
  ): Promise<void> {
    // Validation
    if (!content?.trim()) {
      throw new Error('Content cannot be empty')
    }

    if (!title?.trim()) {
      throw new Error('Title cannot be empty')
    }

    if (!ExportFactory.getSupportedFormats().includes(format)) {
      throw new Error(`Unsupported format: ${format}`)
    }

    const exportData: ExportData = {
      content: content.trim(),
      title: title.trim(),
      options
    }

    try {
      const exporter = ExportFactory.createExporter(format, exportData)
      await exporter.export()
    } catch (error) {
      console.error(`Export failed for format ${format}:`, error)
      throw error
    }
  }
}

// Backward compatibility export
export const exportDocument = DocumentExportService.exportDocument.bind(DocumentExportService)

// Usage examples:
/*
// Method 1: Using the service class
import { DocumentExportService, ExportOptions } from './exportService'
await DocumentExportService.exportDocument('pdf', content, title, options)

// Method 2: Using the backward-compatible function
import { exportDocument, ExportOptions } from './exportService'
await exportDocument('pdf', content, title, options)
*/

const exportOptions: ExportOptions = {
  includeHeader: true,
  includeFooter: true,
  includeTimestamp: true,
  customStyles: 'body { font-size: 14px; }',
  pageMargins: '30px'
}